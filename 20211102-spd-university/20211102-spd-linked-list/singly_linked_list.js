class SinglyLinkedListItem {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

export class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.length = 0;
  }

  get size() {
    return this.length;
  }

  get isEmpty() {
    if (this.length === 0) {
      return true;
    } else {
      return false;
    }
  }


  // ===================================================================
  // (v)Добавить узлы в конец списка
  // ===================================================================
  // С помощью rest-параметра собрать переданные аргументы в массив
  append(...values) {
    // Обработать каждое переданное значение
    values.forEach(item => {
      // 1. Создать экземпляр узла
      let newNode = new SinglyLinkedListItem(item);

      // 2. Если список пустой
      if (this.head === null) {
        // 2.1. Созданный узел сделать "головным"
        this.head = newNode;
      }

      // 3. Иначе (если список не пустой)
      else {
        // 3.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
        let currentNode = this.head;
        
        // 3.2. Пока у текущего узла есть ссылка (next) на следующий узел...
        while (currentNode.next !== null) {
          // 3.3. Делать следующий узел текущим (так дойдёт до последнего узла)
          currentNode = currentNode.next
        }
        // 3.4. Когда "текущий" узел дойдёт до последнего, добавить ещё один узел
        currentNode.next = newNode
      }

      // 4. Увеличить длину списка на 1
      this.length++;
    });
  }


  // ===================================================================
  // (v)Получить значение узла с указанным индексом
  // ===================================================================
  at(index) {
    // 1. Если список пустой
    if (this.head === null) {
      // 1.1. Нечего искать, поэтому вернуть "undefined"
      return undefined;
    }

    // 2. Иначе (если список не пустой)
    else {
      // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
      let currentNode = this.head;
      // 2.2. Счётчик узлов. Начальное значение
      let count = 0;

      // 2.3. Пока счётчик меньше нужного индекса
      while (count <= index) {
        // 2.4. Если счётчик дошёл до искомого индекса, вернуть значение
        if (count === index) return currentNode.value;

        // 2.5. Если у текущего элемента нет ссылки на следующий узел, значит
        // .... закончились узлы, не дойдя до нужного индекса
        if (currentNode.next === null) return undefined;

        // 2.5. Перейти к следующему узлу, сделав следующий узел текущим
        currentNode = currentNode.next;
        // 2.7. Увеличить индекс на 1
        count++;
      }
    }
  }

  // ===================================================================
  // (v)Очистить список
  // ===================================================================
  clear() {
    // 1. Очистить "головной" узел (автоматически удалятся остальные узлы)
    this.head = null;

    // 2. Длину узла установить на "0
    this.length = 0;
  }


  // ===================================================================
  // (v)Проверить наличие узла с указанным значением
  // ===================================================================
  contains(value) {
    // 1. Если список пустой, искать нечего, поэтому вернуть "false"
    if (this.head === null) return false;

    // 2. Если список не пустой
    // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    // 2.2. Пока очередной текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 2.3. Если текущий узел имеет искомое значение, вернуть "true"
      if (currentNode.value === value) return true;

      // 2.4. Если у очередного текущего элемента нет ссылки на следующий узел,
      // .... значит закончились узлы, не дойдя до нужного — вернуть "false"
      if (currentNode.next === null) return false;

      // 2.5. Перейти к следующему узлу, сделав следующий узел текущим
      currentNode = currentNode.next;
    }
  }


  // ===================================================================
  // (v)Найти узел с указанным значением и вернуть индекс
  // ===================================================================
  indexOf(value) {
    // 1. Если список пустой, искать нечего, поэтому вернуть "-1"
    if (this.head === null) return -1;

    // 2. Если список не пустой
    // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;
    // 2.3. Пока очередной текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 2.4. Если текущий узел имеет искомое значение, вернуть индекс
      if (currentNode.value === value) return count;

      // 2.5. Если следующего узла нет, значит в списке вообще нет узла 
      // .... с искомым значением — вернуть "-1"
      if (currentNode.next === null) return -1;

      // 2.6. Иначе следующий узел сделать текущим
      currentNode = currentNode.next;
      // 2.7. Увеличить счётчик
      count++;
    }
  }


  // ===================================================================
  // (v)Добавить узел в указанном месте
  // ===================================================================
  insert(index, value) {
    // 1. Создать новый узел
    const newNode = new SinglyLinkedListItem(value);

    // 2. Если список пустой
    if (this.head === null) {
      // 2.1. Добавить элемент в конец, используя метод "append()"
      this.append(value);
      // 2.2. Выйти из функции
      return;
    }

    // 3. Если нужно добавить узел на первое место
    if (index === 0) {
      // 3.1. Использовать метод "prepend()"
      this.prepend(value);
      // 3.2. Выйти из функции
      return;
    }

    if (index === this.length) {
      this.append(value);
      return;
    }

    // 3. Если нужно добавить в другое место
    // 3.1. "Головной" узел сделать предыдущим (перебор будет начинаться не
    // .... с него, а со второго узла)
    let prevNode = this.head;
    // 3.1. Текущим сделать второй узел
    let currentNode = this.head.next;
    // 3.2. Счётчик узлов. Начальное значение (не "0", а "1")
    let count = 1;
    // 3.3. Пока очередной текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 3.4. Если "count" равен искомому индексу
      if (count === index) {
        // 3.5. Предыдущему узлу задать ссылку на новый узел
        prevNode.next = newNode;

        // 3.6. Новому узлу задать ссылку на текущий узел
        newNode.next = currentNode;

        // 3.7. Увеличить длину списка
        this.length++;
      }

      // 3.8. Если следующего узла нет, значит такого индекса нет (вернуть список)
      if (currentNode.next === null) return false;

      // 3.9. Текущий узел сделать предыдущим
      prevNode = currentNode;
      // 3.10. Следующий узел сделать текущим
      currentNode = currentNode.next;
      // 3.11. Увеличить счётчик
      count++;
    }
  }


  // ===================================================================
  // (v)Добавить узел в начало списка
  // ===================================================================
  prepend(value) {
    // 1. Создать новый узел
    const newNode = new SinglyLinkedListItem(value);

    // 2. Новому узлу задать ссылку на текущий "головной" элемент
    newNode.next = this.head;

    // 3. Сделать новый элемент "головным"
    this.head = newNode;

    // 4. Увеличить длину массива
    this.length++;
  }

  
  // ===================================================================
  // (v)Удалить узел с заданным индексом
  // ===================================================================
  remove(index) {
    let prevNode = null;
    // "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    let deletedNode = null;

    // 1. Если список пустой, нечего удалять
    if (this.head === null) return undefined;

    // 2. Если передали индекс меньше нуля или больше длины списка, 
    // .. ничего не делать
    if (index < 0 || index >= this.length) return undefined;

    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;

    // 3. Пока очередной текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 4.1. Если удаляется первый узел, после которого нет узла
      if (count === index && count === 0 && currentNode.next === null) {
        // Сохранить удаляемый узел
        deletedNode = this.head;
        // Удалить головной узел
        this.head = null;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }
      // 4.2. Если удаляется первый узел, после которого есть узел
      if (count === index && count === 0 && currentNode.next !== null) {
        // Сохранить удаляемый узел
        deletedNode = this.head;
        // Головным сделать следующий узел
        this.head = currentNode.next;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }
      // 4.3. Если удаляется НЕ первй узел, после которого нет узла
      else if (count === index && count > 0 && currentNode.next === null) {
        // Сохранить удаляемый узел
        deletedNode = currentNode;
        // У предыдущего элемента удалить ссылку "next"
        prevNode.next = null;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }
      // 4.4. Если удаляется НЕ первй узел, после которого нет узла
      else if (count === index && count > 0 && currentNode.next !== null) {
        // Сохранить удаляемый узел
        deletedNode = currentNode;
        // У предыдущего элемета задать ссылку на следующий элемент
        prevNode.next = currentNode.next;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }

      // 5. Если ничего не совпало
      // 5.1. Текущий узел сделать предыдущим
      prevNode = currentNode;
      // 5.2. Следующий узел сделать текущим
      currentNode = currentNode.next;
      // 5.3. Увеличить счётчик на 1
      count++;
    }
  }

  // ===================================================================
  // (v)Заменить значение узла в указанной позиции
  // ===================================================================
  replace(index, value) {
    // 1. Если список пустой
    if (this.head === null) {
      // 1.1. Нечего искать, поэтому вернуть "null"
      return undefined;
    }

    // 2. Если список не пустой
    // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;

    // 3.1. Пока счётчик меньше нужного индекса
    while (count <= index) {
      // 3.2. Если счётчик дошёл до искомого индекса, заменить значение
      if (count === index) currentNode.value = value;

      // 3.3. Если у текущего элемента нет ссылки на следующий узел, значит
      // 3.4. ... закончились узлы, не дойдя до нужного индекса
      if (currentNode.next === null) return undefined;

      // 2.5. Перейти к следующему узлу, сделав следующий узел текущим
      currentNode = currentNode.next;
      // 3.6. Увеличить индекс на 1
      count++;
    }
  }

  
  // ===================================================================
  // Сортировать узлы списка
  // ===================================================================
  sort(sortFunc) {
    // 1. Если список пустой, вернуть пустой массив
    if (this.isEmpty) {
      return [];
    }
    // Преобразовать в массив и отсортировать
    const sortedArray = [...this.toArray()].sort(sortFunc);
    // Очистить список
    this.clear();
    // Добавить в список узлы с указанным значением
    this.append(...sortedArray)

    return sortedArray;
  }


  // ===================================================================
  // (v)Вернуть массив узлов
  // ===================================================================
  toArray() {
    // 1. Если список пустой, вернуть пустой массив
    if (this.isEmpty) {
      return [];
    }

    // 2. Переменные
    // 2.1. Массив, в который будут добавляться значения узлов
    const nodesArr = [];
    // 2.2. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;

    // 3. Пока очередной текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 3.1. Добавить узел в массив
      nodesArr.push(currentNode);
      // 3.2. "Следующий" узел сделать "текущим"
      currentNode = currentNode.next;
    }

    // 3. Вернуть массив значений узлов
    return nodesArr.map(item => item.value);
  }


  // ===================================================================
  // (v)Итерирование
  // ===================================================================
  // Метод, делающий объект итерируемым
  [Symbol.iterator]() {
    const entries = this.toArray();
    let index = 0;

    // Метод должен возвращать объект с методом "next()"
    return {
      // Чтобы получить следующее значение, цикл "for..of" будет вызывать метод "next()"
      next() {
        // Метод "next()" должен возвращать объект с двумя свойствами
        const result = {
          value: entries[index],
          done: index >= entries.length
        };

        index++;

        return result;
      }
    }
  }
}